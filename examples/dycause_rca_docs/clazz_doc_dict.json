{
    "20&@C.SPOT.SPOT": "# Class Documentation\n\n---\n\n## Class Name: SPOT (Streaming Peaks-Over-Threshold)\n\n---\n\n## Functionality\nThe SPOT class implements the Streaming Peaks-Over-Threshold algorithm on a univariate dataset. The goal of the SPOT algorithm is to detect abnormal events in a dataset by setting a threshold that separates normal and extreme events.\n\n---\n\n## Attributes\nThe SPOT class uses both public and private attributes to store and manage information for the Peaks and Threshold algorithm.\n\n### Public Attributes:\n\n- `proba` (`float`): The user-selected detection level (risk).\n- `extreme_quantile` (`float`): The current threshold that separates normal and extreme events.\n- `data` (`numpy.array`): The data stream for analysis.\n- `init_data` (`numpy.array`): The initial batch of observations used for the calibration or initialization step.\n- `init_threshold` (`float`): The initial threshold calculated during the calibration step.\n- `peaks` (`numpy.array`): The array containing peaks (abnormal events) that exceed the initial threshold.\n- `n` (`int`): The total number of observed values.\n- `Nt` (`int`): The total number of observed peaks.\n\n### Private Attributes:\n\nNo private attributes are defined for this class.\n\n---\n\n## Methods (Public)\n\n- `__init__`\n- `__str__`\n- `add`\n- `fit`\n- `initialize`\n- `plot`\n- `run`\n- `_grimshaw`\n- `_log_likelihood`\n- `_quantile`\n- `_rootsFinder`\n\n---\n\n## Constructor: __init__\nThe constructor initializes a SPOT object with a user-defined detection level (risk) and sets initial values for parameters like `extreme_quantile`, `data`, `init_data`, `init_threshold`, `peaks`, `n`, and `Nt`.\n\nParameters:\n\n- `q` (`float`, optional): The detection level or risk. Defaults to 1e-4.\n\n---\n\n## Inheritance\nThe SPOT class does not inherit from any class, nor is it extended by other classes.\n\n---\n\n## Examples\n```python\n# Initialising a SPOT object with a detection level of 1e-3\nspotObject = SPOT(q=1e-3)\n\n# Fitting the data\nspotObject.fit([1,2,3,4,5], [6,7,8,9,10])\n\n# Running the SPOT algorithm\nresults = spotObject.run(with_alarm=True)\n\n# Printing the results\nprint(results)\n```\n\n---\n\n## Exceptions \n\n- The `fit` and `add` methods may raise a `TypeError` if provided input data is not supported (only `list`, `numpy.array`, or `pandas.Series` types are supported).\n\n- The `initialize` method may raise a `TypeError` if `level` is not of type float or `verbose` is not of type bool.\n\n- The `_quantile` method may raise a `ZeroDivisionError` if `gamma` parameter equals to 0.\n\n- The `_log_likelihood` method may raise a `ValueError` if `sigma` parameter is less or equal to 0.\n\n---\n\n## Usage Scenarios\nThe primary use for the SPOT class is to perform anomaly detection in time-series data using the SPOT algorithm. Therefore, this class is particularly useful in fields of anomaly detection such as network security, fraud detection, heath monitoring, and fault detection in safety critical systems.",
    "20&@C.SPOT.biSPOT": "# Class Documentation\n\n## Class Name: biSPOT\n\nThis class is designed to run the biSPOT algorithm on univariate dataset (upper and lower bounds). It plays a pivotal role in differentiating between normal and abnormal events in a data stream using the Streaming Peaks-Over-Threshold method, which is especially useful in real-time anomaly detection.\n\n## Functionality\n\nThe purpose of the biSPOT class is to conduct anomaly detection on data streams. It adjusts to the data it receives, creating an initial calibration based on a batch of data and subsequently updating its parameters to fit the behavior of the accumulated data.\n\n## Attributes\n\n### Public Attributes\n1. **proba** (`float`): \n    - Represents the detection level (risk) as chosen by the user.\n2. **extreme_quantile** (`float`): \n    - Provides the current threshold that distinguish normal and abnormal events.\n3. **data** (`numpy.array`): \n    - Stores the stream of incoming data.\n4. **init_data** (`numpy.array`): \n    - Contains an initial batch of observations that is used during the calibration or initialization phase.\n5. **init_threshold** (`float`): \n    - Denotes the initial threshold computed during the calibration step.\n6. **peaks** (`numpy.array`): \n    - An array of peaks or excesses above the initial threshold.\n7. **n** (`int`): \n   - Number of observed values.\n8. **Nt** (`int`): \n   - Number of observed peaks.\n\n### Private Attributes\nNone.\n\n## Methods\nApart from the constructor, the class mainly includes six methods: `_grimshaw`, `_log_likelihood`, `_quantile`, `_rootsFinder`, `fit`, `initialize`, `run`, `plot`, and `add`.\n\n## Constructor (`__init__`):\n\nThe constructor initializes a new instance of the biSPOT class, setting the detection level to the value provided by the user while initializing other instance variables.\n\n## Inheritance\nThe biSPOT class does not inherit from another class, nor is it extended by other classes.\n\n## Examples\nA simple example of initializing and using the biSPOT class is as follows:\n```python\nbspot_instance = biSPOT(0.001) # create instance with detection level set to 0.001\nbspot_instance.fit(np.array([1, 2, 3]), np.array([4, 5, 6])) # initialize data for the instance\noutput = bspot_instance.run() # run the biSPOT algorithm for the instance\n```\n\n## Exceptions\nExceptions can be raised in methods if the provided parameters are not as expected. For example, providing a data type other than a list, numpy array, or pandas series in the 'fit' or 'add' method will raise an error.\n\n## Usage Scenarios\nThe biSPOT class is typically used for anomaly detection on univariate data streams in real-time. This makes it suitable for scenarios such as network intrusion detection, fault detection in machinery, and monitoring patient health in real-time.",
    "20&@C.SPOT.bidSPOT": "---\n\n## Class Name: DSPOT\n\nThe DSPOT class is designed to aid in running the DSPOT algorithm on a univariate dataset. DSPOT is a streaming data anomaly detection algorithm that performs a peaks-over-threshold analysis and fits a Generalized Pareto Distribution (GPD) to the excesses.\n\n---\n\n## Functionality:\n\nThis class facilitates the processing of uni-dimensional real-valued data streams for anomaly detection. It provides support for running the DSPOT algorithm, which determines whether certain outliers are \"peaks\" over a certain threshold and whether they pose possible threats or anomalies.\n\n---\n\n## Attributes\n\nThe DSPOT class has several attributes that hold data and parameters related to the DSPOT algorithm and its operations. \n\n### Public Attributes:\n\n- `proba (float)`: Specifies the detection level or risk, chosen by the user.\n- `depth (int)`: Refers to the number of observations used to compute the moving average. \n- `extreme_quantile (float)`: Specifies the current threshold, which acts as the boundary between normal and abnormal events.\n\n### Private Attributes:\n\n- `data (numpy.array)`: Holds the streaming data.\n- `init_data (numpy.array)`: Stores the initial batch of observations used for the calibration or initialization step.\n- `init_threshold (float)`: Contains the initial threshold computed during the calibration step.\n- `peaks (numpy.array)`: Stores the peaks or the excesses above the initial threshold.\n- `n (int)`: Keeps track of the number of observed values.\n- `Nt (int)`: Holds the number of observed peaks.\n\n---\n\n## Methods:\n\nPublic Methods:\n\n- `__init__()`\n- `run()`\n- `plot()`\n- `initialize()`\n- `fit()`\n- `add()`\n\nPrivate methods:\n\n- `_rootsFinder()`\n- `_quantile()`\n- `_log_likelihood()`\n- `_grimshaw()`\n- `__str__()`\n\n\n## Constructor:\n\nThe constructor method (`__init__(self, q=1e-4, depth=10)`) initializes the DSPOT class. It sets the detection level (`q`) of the DSPOT algorithm, the number of observations to calculate the moving average (`depth`) and initializes various dictionaries meant to represent separate thresholds and values. \n\n---\n\n## Inheritance:\n\nThe documentation does not indicate any inheritance relationship.\n\n---\n\n## Examples:\n\nCreating a DSPOT class instance:\n```python\ndsp = DSPOT(q=0.001, depth=15)\n```\n\nUsing the fit method:\n```python\ndsp.fit([1,2,3,4,5], [6,7,8,9,10])\n```\n\nRunning the DSPOT algorithm:\n```python\ndsp.run(with_alarm=True, plot=False)\n```\n\n---\n\n## Exceptions:\n\nNot specified in the given context. However, methods may raise exceptions related to incorrect data types, shapes, or parameter values.\n\n---\n\n## Usage Scenarios:\n\nThe DSPOT class can be useful in situations of real-time univariate anomaly detection in streaming data series. It has applications in areas like financial transactions, IT infrastructure monitoring, IoT device data tracking, etc. where spotting outliers/anomalies in real-time is critical.",
    "20&@C.SPOT.dSPOT": "**Class Documentation**\n\n---\n\n**Class Name**: DSPOT\n\nThe DSPOT class is designed to run the DSPOT (Dependency-Aware Spot - Streaming-Peaks-over-Threshold) algorithm on a univariate dataset (upper-bound). \n\n**Functionality**:\n\nThe class allows you to conduct real-time anomaly detection on data streams based on the Peaks-Over-Threshold (POT) method.\n\n**Attributes**:\n\n1. **Public Attributes**:\n\n    - `proba` (float): The detection level, chosen by the user.\n    - `depth` (int): The number of observations to compute the moving average.\n    - `data` (numpy.array): The stream of data.\n    - `init_data` (numpy.array): The initial batch of observations for the calibration or initialization step.\n    - `peaks` (numpy.array): An array of peaks, which are the excesses above the initial threshold.\n\n2. **Private Attributes**:\n\n    - `__extreme_quantile`: Current threshold (bound between normal and abnormal events).\n    - `__init_threshold` (float): The initial threshold computed during the calibration step.\n    - `__n` (int): Number of observed values.\n    - `__Nt` (int): Number of observed peaks.\n\n**Methods**:\n- `__init__`\n- `run`\n- `plot`\n- `initialize`\n- `fit`\n- `add`\n- `_rootsFinder`\n- `_quantile`\n- `_log_likelihood`\n- `_grimshaw`\n- `str`\n\n**Constructor**: \n\nThe `__init__()` constructor method initializes an instance of the class. It sets up the initial values for `q` and `depth` as well as initializing other attributes of the class.\n\n**Inheritance**: \n\nIf the DSPOT class inherits any attributes or methods from another class or has any subclasses, these will be described here.\n\n**Exceptions**: \n\nThe class does not specify any explicitly raised exceptions. However, exceptions could be raised in case of inappropriate data or arguments in method calls.\n\n**Usage Scenarios**:\n\nThe DSPOT class could be used in financial analysis, IoT sensor data monitoring, server network traffic monitoring, health care monitoring or any kind of situation where real-time anomaly detection in streaming data is needed.\n\n**Examples**:\n\n```python\n# First, initialize an instance of the DSPOT class:\ndsp_obj = DSPOT(0.01, 10)\n\n# Then, fit data to the instance:\ninit_data = np.random.normal(0, 1, 1000)\ndata = np.random.normal(0, 1, 2000)\ndsp_obj.fit(init_data, data) \n```",
    "32&@C.dycause_lib.cnts_prune": "---\nClass Documentation\n\n# Class Name\n\nThe class name is `StatisticsCollector`.\n\n# Functionality\n\nThis class is designed to manage and provide an overview of counts for different result categories such as promising results, non-promising results, uncertain results, and initial results. It gives a way to keep track of these counts and to represent the current state of these counts in a string format.\n\n# Attributes\n\n## Public Attributes \n- `cnt_promising` represents the count of promising results.\n- `cnt_promising_not` represents the count of non-promising results.\n- `cnt_not_sure` represents the count of results that are uncertain.\n- `cnt_initial` represents the initial count of results before they are classified.\n\n## Private Attributes \nThis class does not have any private attributes.\n\n# Methods\n- `__init__(self, cnt_promising, cnt_promising_not, cnt_not_sure, cnt_initial)` \n- `__str__(self)\n  \n# Constructor\n The constructor method `__init__` is used to initialize the `StatisticsCollector` class instance with the counts of promising, non-promising and uncertain results and the initial unsorted count. Here are the parameters it accepts:\n  \n- `cnt_promising` (`int`): count of promising results.\n- `cnt_promising_not` (`int`): count of non-promising results.\n- `cnt_not_sure` (`int`): count of results that are uncertain.\n- `cnt_initial` (`int`): initial count of results before they are sorted.\n\n# Inheritance\nThis `StatisticsCollector` class does not derive or inherit functionality from any classes, nor is it used as a base class for any subclasses.\n\n# Examples\n```python\nstat_collector = StatisticsCollector(10, 20, 30, 60)\nprint(stat_collector)  # Outputs: Promising: 00010, PromisingNot: 00020, NotSure: 00030, Initial: 00060\n```\n\n# Exceptions \nThe class doesn't raise any specific exceptions. However, as counts are assumed to be integers, typical Python exceptions related to type mismatches (e.g., TypeError) may arise if non-integer values are provided.\n\n# Usage Scenarios\nThis `StatisticsCollector` class could be used in programs for analysis and statistics collection where there is a requirement to maintain and display the counts of results categorized as promising, non-promising, and uncertain, along with the initial count of the results.\n\n---"
}